kafka是一款消息队列处理框架，一般用于生产者和消费者之间的解耦，流量削峰，消息传递，日志收集等场景。<br>

kafka结构一般有三部分，分别是producer，broker，consumer，producer用于消息的生产，broker一般用于消息的分发以及消息的持久化，consumer用于消息的消费。<br>

broker也就是kafka服务器。对于一个消息来说，这个消息有自己专属的topic，这个topic只是一个概念，也就是消息要发送的地方，每个topic是有多个
partition组成的，对于每个partition来说，消息只能append到每个partition的尾部。<br>

replica
--
为了防止消息丢失，所以kafka有备份的机制，这些备份的日志被称为replica（副本），这些副本是保存在broker上面的。同时对于同一个partition的多个
replica是不会保存在同一台broker上面的，因为如果一台broker挂了，那所有replica都不存在了。副本分为leader replica
以及follower replica，follower replica是不能提供服务给客户端的，如果leader挂了的话，会从剩下的follower当中选举出一个leader。注意并不是所有的
follower replica都有机会被选举为leader，只有那些在ISR（in-sync replica)当中的副本才会，这些集合当中的replica与leader保持着同步。

producer
--
producer发送消息的流程是，首先构造消息对象，然后对其进行压缩（可选）以及序列化，然后选择发送到哪个分区，有专门的partitioner（分区器）进行设置，分区器会确保具有相同key的消息发送到同一个分区上面。发送有两种方式，分别是同步以及异步发送，这两种方式是通过future实现的，前者
是通过future.get无限等待，而后者有future对象可以稍后获取结果，这就是回调机制。在发送完之后，broker可以返回结果给producer，producer可以设置参数为
不等待broker确认结果（acks=0），也可以是broker等到ISR当中所有副本写入之后再发（acks=all或者-1），也可以是只等到leader replica写进去就发送
（acks=1），因此不同的方式会影响吞吐率。无消息丢失配置的设置参数部分在producer以及broker进行配置，producer部分配置参数如下acks=all以及尝试重发无限次，手动commit等等。producer在多线程情况下会有多线程单producer实例以及多线程多producer实例两种方式，kafkaproducer是线程安全的，所以多线程单producer实例也是线程安全的。

consumer
--
consumer有consumer group以及standalone consumer两种，前者是一个group当中有多个consumer，后者没有分组的概念，单个consumer进行消费。对于group来说，topic的每个消息只会被group当中的一个consumer进行消费。如果有consumer挂了，那么group会将该consumer负责的分区转给另外一个consumer进行负责，这叫rebalance(重平衡）。重平衡的时机有订阅的topic发生改变，有新的consumer加入或者离开分组，分区发生变化三种。有一个rebalance generation的概念，
也就是说如果发生一次generation就加1，类似gc。
目前，kafka只会维护单个分区内消息的有序性，而不会维护全局的消息有序。位移提交的概念是说消费者要定期向kafka集群汇报自己的消费进度，这叫（offset commit），__consumer_offsets文件存储的是消费的位移。consumer获取消息采用的是类似linux的轮询的方式，在poll方法中进行轮询，使用一个线程同时管理多个socket连接。新版本的consumer是一个多线程的，一个是创建consumer的主线程，一个是后台心跳线程，两个线程，但是个人感觉是一个线程起着主要的作用。并且新版本的consumer不是线程安全的。对于语义交付是在consumer控制的，最多消费一次（at most once)，至少消费一次（at least once）以及精确一次(exactly once).如果consumer在消费之前就提交位移，那么可以实现at most once，如果消费之后 那么就是at least once。集群会在所有broker当中选择一个broker当做coordinator，用于组成员管理，消费分配方案的制订以及提交位移等等，提交位移有自动提交以及手动提交两种方式。同样，consumer也有全局单consumer多线程以及每个线程都有一个consumer两种方式。



