第2章
--
##第1条：用静态工厂方法代替构造器
优点：<br>
      1、静态工厂方法不必在每次调用它们的时候都创建一个新对象，确保实例受控类，比如singleton（单例类）<br>
      2、可以返回原返回类型的任何子类型对象<br>
      3、在创建参数化类型实例的时候，它们使代码变得简洁<br>
缺点：<br>
      1、类如果不含公有的或者受保护的构造器，就不能被子类化<br>
      2、它们与其他的静态方法实际上没有任何区别
##第2条：遇到多个构造器参数时要考虑用构造器
`重叠构造器模式`：为了适应不同情况，重复写具有不同个数参数的构造函数<br>
`JavaBeans模式`：调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数<br>
`Builder模式：` 不直接生成想要的对象，而是让客户端利用所有必要的参数调用<br>
`通配符`是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符
或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“*Not?pad”可以对应Notpad\MyNotpad【*可以代表任何文字】;
Notpad\Notepad【?仅代表单个字】;Notepad\Notepod【ao代表a与o里二选一】，其余以此类推。
##第3条：用私有构造器或者枚举类型强化Singleton属性
JAVA`反射机制`是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>
在外部调用`静态方法`时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。<br>
单元素的枚举类型已经成为实现singleton的最佳方法。如下
```java
public enum Elvis{
INSTANCE;
public void leaveTheBuilding(){...}
}
```
`抽象方法`必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为`抽象类`，抽象类必须在类前用abstract关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。<br>
####抽象类与接口类的区别
该部分来自http://www.cnblogs.com/dolphin0520/p/3811437.html
#####1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>

#####2.设计层面上的区别

　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。<br>

　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。<br>
##第4条：通过私有构造器强化不可实例化的能力
让类包含私有构造器，它就不能被实例化了
```java
public class UtClass
{
 private UtClass(){
   throw new AssertionError();
}
}
```
||类内部|本包|子类|外部包|
|---------|-----|-----|----|------|
|public| 是|是|是|是|
|procted|是|是|是|否|
|default|是|是|否|否|
|private|是|否|否|否|
java几种关键字的作用范围如上所示
##第5条：避免创建不必要的对象
如果某些变量只用一次而不改变它的值就不要每次都创建，用static final修饰即可<br>
优先使用基本类型（比如long）而不是装箱基本类型（比如Long），注意无意识的自动装箱
##第6条：消除过期的对象引用
如果一个栈先增长，后收缩，从栈中弹出的对象不会被当做垃圾回收，因为栈维护着对这些对象的过期引用<br>
只要类是自己管理内存，应该警惕内存泄漏。另外内存泄漏的另外一个来源是缓存。第三个来源是监听器和其他回调<br>
###对象的引用分类
来自http://zhangjunhd.blog.51cto.com/113473/53092/
####⑴强引用（StrongReference）
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
 
####⑵软引用（SoftReference）
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（下文给出示例）。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
 
####⑶弱引用（WeakReference）
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
 
####⑷虚引用（PhantomReference）
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

##第7条：避免使用终结方法


