深入理解计算机系统
==
第1章：计算机系统漫游
--
预处理器（处理后以.i作为文件拓展名，就是插入所有#include指定的文件，并且扩展#define声明指定的宏）、编译器（.s为文件扩展名，此时已是汇编代码）、汇编器（.o为文件扩展名，为 二进制文件）和链接器一起构成了 编译系统。<br>
2016/10/25看到5页<br>
ALU算术/逻辑单元 PC程序计数器，在任何时刻，PC都指向主存中的某条机器语言指令。`主存`是一组动态随机存取存储器（DRAM）芯片组成的。L1和L2的高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。寄存器文件位于CPU中。处理器在进程间切换的机制叫上下文切换。一个进程由多个称为线程的执行单元组成。<br>
`并发（concurrency）`：指的是一个同时具有多个活动的系统；`并行（parallelism）`指的是用并发使一个系统运行更快。`超线程`有时称为同时多线程：是一项允许一个CPU执行多个控制流的技术。`SIMD`并行，单指令，多数据。字长决定最重要的就是虚拟地址空间的最大大小。字长为w，程序最多访问2^w个字节。`大端法`和`小端法`是存储字节的两种方法。

第3章：程序的机器级表示
--
指令集体系结构（ISA）。<br>
2016/10/27看到108页 <br>
反汇编指令 命名规则与GCC生成的有差别，有些指令后有"l",这些后缀是大小提示符，表示字节大小，l为双字，为4个字节，大多数情况下可以省略。常用指令字节数比较少。GCC可以产生汇编语言。有ATT与Intel汇编代码格式。Intel用“字”表示16位数据类型，32位为"双字”。英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32）。一个IA32的CPU包含一组8个存储32位值的寄存器，用来存储整数数据和指针，名字都以%e开头。指令的操作数类型可以是立即数（常数值），也可以是寄存器，也可以是存储器这三种。有多种寻址模式:立即数寻址，寄存器寻址，绝对寻址，间接寻址，变址寻址，(基址+偏移量）寻址，比例变址寻址。IA32的栈一般写为栈顶在下，然后入栈时地址减少。对抗缓冲区溢出攻击可以使用栈随机化技术，它是更大一类技术的一种，称为地址空间布局随机化（ASLR）。随机化，栈保护和限制哪部分存储器可以存储可执行代码是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。<br>
为单个过程分配的那部分栈叫栈帧。 寄存器%ebp为帧指针，寄存器%esp为栈指针。栈指针可以移动， 因此大多数信息的访问都是相对于帧指针的。<br>
`转移控制`call指令用于过程调用，效果是将返回地址入栈，ret指令是从栈中弹出地址，从过程调用中返回。
x86-64特点：指针和长整数是64位长。通用目的寄存器组从8个扩展到16个。许多程序状态都保存在寄存器中，而不是栈上。64位寄存器都是以%r开头。<br>
看到188页<br>

第5章：优化程序性能
--
5.1到5.6比较重要，建议仔细看。6.2到6.7比较重要 第7章比较重要，根据http://blog.sina.com.cn/s/blog_4e967c8b0100tkpd.htmlc 10.11重要
http://book.51cto.com/art/201103/249824.htm 这个网址总结了这本书的重点<br>
2016-10-31 看到155页<br>
http://lib.csdn.net/article/c/24763 这个写的递归过程的栈结构，比较详细。<br>
5.4 消除循环的低效率<br>
两个指针可能指向同一个存储器位置的i情况称为存储器别名使用。另外一个妨碍优化的因素是函数调用，这两种情况可能会产生歧义，因此编译器选择不优化。<br>
代码优化有`代码移动`这种方式,就是对于某些值如果不发生变化，则只需要计算一次，不用多次计算。<br>
`内联函数`:在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要非常注意的是对递归函数的内联扩展可能带来部分编译器的无穷编译。
5.5 减少过程调用<br> 
5.6 消除不必要的存储器引用<br>
就是把中间结果累积在临时变量中。
5.8 循环展开<br>
循环展开，英文中称（Loop unwinding或loop unrolling），是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。也就是增加每次迭代计算的元素的数量，减少循环的迭代次数。实验中是对于整数乘法和加法，循环展开会提高性能，但是对于浮点数运算没有改进。此时编译器会基于`重关联变换`做优化，重关联变换就是改变值合并的顺序。之所以不会对浮点数做这种优化是因为编译器对于先对浮点数的结合可能产生不同的结果，所以保持原状，不做优化。
5.9 提高并行性<br>
如果并行度p超过了可用的寄存器数量，那么编译器会溢出，将某些临时值放在栈中，此时，性能会急剧下降。<br>
 分支预测：就是处理器遇到分支语句的时候会提前判断语句会怎么执行，然后按照自己的推测执行下面的代码，如果推测正确那么就会节省很多时间，如果推测错误，那么就要丢弃自己之前的工作，然后从正确的分支执行。http://www.cnblogs.com/yangecnu/p/4196026.html 这个网址对于分支预测的解释比较好。<br>
 加载是将数据从存储位置读到寄存器，而存储是将数据从寄存器写到存储器。<br>
 2016/11/2 星期三 看到364页
