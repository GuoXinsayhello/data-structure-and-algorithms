深入理解计算机系统
==
第1章：计算机系统漫游
--
预处理器（处理后以.i作为文件拓展名，就是插入所有#include指定的文件，并且扩展#define声明指定的宏）、编译器（.s为文件扩展名，此时已是汇编代码）、汇编器（.o为文件扩展名，为 二进制文件）和链接器一起构成了 编译系统。<br>
2016/10/25看到5页<br>
ALU算术/逻辑单元 PC程序计数器，在任何时刻，PC都指向主存中的某条机器语言指令。`主存`是一组动态随机存取存储器（DRAM）芯片组成的。L1和L2的高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。寄存器文件位于CPU中。处理器在进程间切换的机制叫上下文切换。一个进程由多个称为线程的执行单元组成。<br>
`并发（concurrency）`：指的是一个同时具有多个活动的系统；`并行（parallelism）`指的是用并发使一个系统运行更快。`超线程`有时称为同时多线程：是一项允许一个CPU执行多个控制流的技术。`SIMD`并行，单指令，多数据。字长决定最重要的就是虚拟地址空间的最大大小。字长为w，程序最多访问2^w个字节。`大端法`和`小端法`是存储字节的两种方法。

第3章：程序的机器级表示
--
指令集体系结构（ISA）。<br>
2016/10/27看到108页 <br>
反汇编指令 命名规则与GCC生成的有差别，有些指令后有"l",这些后缀是大小提示符，表示字节大小，l为双字，为4个字节，大多数情况下可以省略。常用指令字节数比较少。GCC可以产生汇编语言。有ATT与Intel汇编代码格式。Intel用“字”表示16位数据类型，32位为"双字”。英特尔32位架构（英语：Intel Architecture, 32-bit，缩写为IA-32）。一个IA32的CPU包含一组8个存储32位值的寄存器，用来存储整数数据和指针，名字都以%e开头。指令的操作数类型可以是立即数（常数值），也可以是寄存器，也可以是存储器这三种。有多种寻址模式:立即数寻址，寄存器寻址，绝对寻址，间接寻址，变址寻址，(基址+偏移量）寻址，比例变址寻址。IA32的栈一般写为栈顶在下，然后入栈时地址减少。对抗缓冲区溢出攻击可以使用栈随机化技术，它是更大一类技术的一种，称为地址空间布局随机化（ASLR）。随机化，栈保护和限制哪部分存储器可以存储可执行代码是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。<br>
为单个过程分配的那部分栈叫栈帧。 寄存器%ebp为帧指针，寄存器%esp为栈指针。栈指针可以移动， 因此大多数信息的访问都是相对于帧指针的。<br>
`转移控制`call指令用于过程调用，效果是将返回地址入栈，ret指令是从栈中弹出地址，从过程调用中返回。
x86-64特点：指针和长整数是64位长。通用目的寄存器组从8个扩展到16个。许多程序状态都保存在寄存器中，而不是栈上。64位寄存器都是以%r开头。<br>
看到188页<br>

第5章：优化程序性能
--
5.1到5.6比较重要，建议仔细看。6.2到6.7比较重要 第7章比较重要，根据http://blog.sina.com.cn/s/blog_4e967c8b0100tkpd.htmlc 10.11重要
http://book.51cto.com/art/201103/249824.htm 这个网址总结了这本书的重点<br>
2016-10-31 看到155页<br>
http://lib.csdn.net/article/c/24763 这个写的递归过程的栈结构，比较详细。<br>
5.4 消除循环的低效率<br>
两个指针可能指向同一个存储器位置的i情况称为存储器别名使用。另外一个妨碍优化的因素是函数调用，这两种情况可能会产生歧义，因此编译器选择不优化。<br>
代码优化有`代码移动`这种方式,就是对于某些值如果不发生变化，则只需要计算一次，不用多次计算。<br>
`内联函数`:在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要非常注意的是对递归函数的内联扩展可能带来部分编译器的无穷编译。
5.5 减少过程调用<br> 
5.6 消除不必要的存储器引用<br>
就是把中间结果累积在临时变量中。
5.8 循环展开<br>
循环展开，英文中称（Loop unwinding或loop unrolling），是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。也就是增加每次迭代计算的元素的数量，减少循环的迭代次数。实验中是对于整数乘法和加法，循环展开会提高性能，但是对于浮点数运算没有改进。此时编译器会基于`重关联变换`做优化，重关联变换就是改变值合并的顺序。之所以不会对浮点数做这种优化是因为编译器对于先对浮点数的结合可能产生不同的结果，所以保持原状，不做优化。
5.9 提高并行性<br>
如果并行度p超过了可用的寄存器数量，那么编译器会溢出，将某些临时值放在栈中，此时，性能会急剧下降。<br>
 分支预测：就是处理器遇到分支语句的时候会提前判断语句会怎么执行，然后按照自己的推测执行下面的代码，如果推测正确那么就会节省很多时间，如果推测错误，那么就要丢弃自己之前的工作，然后从正确的分支执行。http://www.cnblogs.com/yangecnu/p/4196026.html 这个网址对于分支预测的解释比较好。<br>
 加载是将数据从存储位置读到寄存器，而存储是将数据从寄存器写到存储器。<br>
 2016/11/2 星期三 看到364页
 5.13 应用<br>
1)高级设计：为手边的问题选择适当的算法和数据结构，要特别警觉，避免使用会渐进地产生糟糕性能的算法或编码技术。<br>
2)基本编码原则。避免限制优化的因素，这样编译器就能产生高效代码。 
消除连续的函数调用。在可能时将计算移到循环外，考虑有选择的妥协程序的模块性以获得更大效率。<br>
消除不必要的存储器引用。引入临时变量来保存中间结果，只有在最后的值计算出来时，才能将结果放到数组或全局变量中。<br>
3)低级优化<br>
通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。<br>
通过展开循环降低循环开销。<br>
用功能的风格重写条件操作，使得编译采用条件数据传送。<br>
http://blog.csdn.net/zq602316498/article/details/38796095 这篇博客介绍了TPTP工具来分析Java方法的运行时间，以及线程，从而优化程序，这个插件可以安装在eclipse里面。

第6章：存储器层次结构
--
SRAM比DRAM更快，但是更贵，SRAM用来做高速缓存存储器，高速缓存是作为CPU和主存之间的缓存区域，DRAM用来作为主存以及图形系统的帧缓冲区。SRAM将每一位存储在一个双稳态的存储器单元里面，就是能够无限期地保持在两个不同的电压配置或者状态之一。SRAM只要有电，就会保持不变，DRAM与SRAM在断电后都会丢失信息。<br>
PROM(PROGRAMMABLE ROM,可编程ROM）只能被编程一次。EPROM（Erasable Programmable ROM）可擦写可编程ROM，EEPROM是电子可擦除PROM。固态硬盘是一种基于闪存的存储技术。<br>
有良好局部性的程序比局部性差的程序运行得更快。比如在两层循环中，对一个w二维数组求和，因为二维数组在存储中是以行优先的顺序存储的（也就是先存第一行，再存第二行），所以代码如果是行优先的话那么代码就会具有较好的局部性，反之如果以列优先的话，那么代码的局部性就会比较差。<br>
 评价局部性的简单原则：<br>
1、重复引用同一个变量有良好的时间局部性<br>
2、对于步长为k 的引用的程序，步长越小，空间局部性越小。步长为1 的引用具有良好的空间局部性。k越大，空间局部性越差。<br>
3、对于取指令来说、循环有较好的时间和空间局部性。循环体越小，循环迭代的次数越多，局部性越好<br>
缓存命中就是如果需要第k+1层的数据时，首先在第k层查找该对象，如果该对象刚好缓存在第k层中，就说缓存命中。目前无线缓存的研究就是计算机玩剩下的。<br>
CPU寄存器文件和主存之间一个SRAM高速缓存存储器，称为L1高速缓存（一级缓存），目前有三级h高速缓存。<br>
高速缓存有S个组，每组有E行，每行1个有效位，每行有t个有效位，每行每个高速缓存块有B个字节。<br>
对于局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文件中（时间局部性），步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。


第7章：链接
--
链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程。可以在编译时由静态编译器来完成，也可以在加载和运行时由动态链接器来完成。在计算机科学中，ELF是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储的标准文件格式，也是Linux的主要可执行文件格式。DLL（动态链接库），共享库（也称为共享目标），在Unix系统中通常以.so为后缀。静态库的后缀一般是libxxx.a.整个 函数库的所有数据都会被整合进目标代码中,因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译.动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小.<br>
JNI(JAVA Native Interface,Java本地接口），允许 Java调用本地的C或者C++函数。

第8章：异常
--
ECF异常控制流，异常可以分为四类：中断、陷阱、 故障、终止。中断时异步的，也就是说是来自处理器外部的I/O信号的结果。而 陷阱、故障、终止是同步发生的， 是执行当前指令的结果。陷阱是有意的异常， 是执行一条指令的结果，当用户程序想要请求某些服务时，可以执行某条命令。故障是由错误情况引起的。终止是不可恢复的致命错误的结果。<br>
进程的一个经典定义就是一个执行中的程序的实例。一个逻辑流的执行在时间上与另外一个流重叠，称为并发流。并行流是并发流的真子集，如果两个流并发的运行在不同的处理器 核或者计算机上，那么称它们为并行流。内核模式又叫超级用户模式，运行在该模式下的进程可以执行指令集中的任何指令，访问系统中任何存储器位置，通过设置模式位可以进入内核模式。没有设置模式位时，进程就运行在用户模式中。在进程执行的某些时刻，内核可以决定抢占当前进程，并且重新开始一个先前被抢占的进程，这种决定叫调度。操作系统内核使用上下文切换来实现多任务。<br>
在计算机领域中，子进程为由另外一个进程（对应称之为父进程）所创建的进程。子进程继承了父进程的大部分属性，例如文件描述符。父进程通过fork（）函数创建一个新的运行子进程。<br>
特性：fork函数被父进程调用一次，然而却返回两次，一次是a返回到父进程，一次是返回到创建的子进程；<br>
b父进程与子进程是并发运行的独立进程。<br>
相同的但是独立的地址空间。<br>
共享文件<br>
对于书本494页调用多个fork的例子，每调用一次fork，每个进程都会产生一个自己的子进程（包括原来的z父进程和子进程）。sleep函数将一个进程挂起一段h指定的时间。execve函数在当前进程的上下文中加载并且运行一个新的程序。<br>
非本地跳转，非本地跳转是通过setjmp和longjmps函数提供的。<br>
进程提供给应用两个重要的抽象,1)逻辑控制流，它提供给每个程序一个假象，好像是它在独占地使用处理器，2）私有地址空间，它提供给每个程序一个假象，好像是它在独占地使用主存。
