# data-structure-and-algorithms
《算法导论》
==
#第一部分 基础知识
##第一章
如何任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
“旅行商问题”是NP完全的，归并排序的算法时间正比于nlogn，而插入排序正比于n*n
##第二章
分治算法
一个简单的例子是两堆已经各自排好序的扑克牌,分别比较两堆顶部的牌,把较小的放进第三个最终数组,被抽走的那堆显露新的牌再进行比较
##第三章
函数的增长
3.1
若f(n)=Θ(g(n)),则称g(n)是f(n)的一个渐近紧确界,如果当n>n0时,f(n)小于等于cg(n),则记f(n)=O(g(n)),如果f(n)总大于等于cg(n),则记f(n)=Ω(g(n)).
用o记号表示一个非渐近紧确的上界，o(g(n))记为f(n)<cg(n),注意与大O符号的区别。
用ω记号表示一个非渐近紧确的下界，ω与Ω的关系与o与O记号的关系类似
3.2
向下取整表示小于或等于x的最大整数，向上取整表示大于或者等于x的最小整数
斯特林公式给出了n的阶乘的近似表达式
斐波那契数与黄金分割率fai以及其共轭数有关
##第四章
分治策略
4.2矩阵乘法的Strassen算法
可以通过这个算法把矩阵乘法由基本的Ω(n^3)变为O（n^lg7),但是63页指出,从实用的角度,Strassen算法通常不是解决矩阵乘法的最优选择.
4.3用代入算法求解递归式
分治策略就是把一个大问题分解成很多相似的小问题,在得出递归式后可以尝试猜测出递归式的时间复杂度的具体表现形式,,然后代入得出上界或是下界
4.4用递归树方法求解递归式的表达式,递归式所有结点的代价之和即为总的算法复杂度
4.5用主方法求解递归式有固定的方法
##第五章 
概率分析和随机算法
#第二部分 排序和顺序统计量
##第六章
堆排序
（二叉）堆可以被近似看成一个完全二叉树，除了最底层外，该树是完全充满的
时间复杂度O(nlgn),最大堆与最小堆的概念,构造一个最大堆,以及对堆进行排序,得到一个有序数组
由sedgewick的《算法》可以知道可以用一个数组来表示堆，最顶点放在第一个位置
##第七章
快速排序
在排序算法中，如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是
原址的
快速排序的期望时间复杂度是Θ（nlgn），最坏情况是Θ（n^2)
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
只要分割的两部分比例是常数，算法的运行时间总是O（nlgn）
可以用RANDOMIZED-QUICKSORT首先随机选择主元可以得到期望运行时间
##第八章 线性时间排序
在最坏情况下，任何比较排序算法都要做Ω（nlgn）次比较
###8.2计数排序
计数排序就是有多少个元素小于它就把它放在第几个位置，计数排序的重要性质就是稳定性，具有相同值的元素在输出中相对次序与输入中的相对次序相同
###8.3基数排序  基数排序是一种稳定性排序，是从低位到高位进行排序
###8.4桶排序
桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），其期望运行时间为Θ（n）
9.1同时得到最大值和最小值可以先把输入的一对数据进行比较，然后较小的数据与暂时的最小值比较，较大的数据与暂时的最大值比较
9.2randomized-select方法寻找一个序列中第i小的元素，类似于快速排序，先把数组分为小于以及大于主元的两部分，然后在这两部分中的一个寻找所要求的元素。
9.3作者提出了求中位数的中位数的算法
##第三部分 数据结构
###第十章  基本数据结构
10.1队列是环序的
10.2在链表中可以设置一个哨兵，在代码中可以降低常数因子，使代码简洁
对于没有指针的语言可以用数组来构成链表，每一个对象的关键字，prev以及next都存放在数组中的一个位置上
###第十二章  二叉搜索树
二叉搜索树的高度为k-1，也就是根结点是第0层
Jensen不等式  将一个凸函数f(x)应用到随机变量X上时，假定期望存在且有限，则由詹森不等式可得E[f(x)]≥f(E[X])
###第十三章 红黑树
13.1每个结点红色或者黑色的，根节点是黑色的，对于每个结点从该节点到所有后代叶节点(NIL)的简单路径均包含相同数目的黑色结点。
红黑树:平衡二叉树，广泛用在C++的STL中。map和set都是用红黑树实现的，
统计性能比AVL树更高，AVL树是一种高度平衡的二叉搜索树，对于每个结点x，x的左右子树的高度差至多为1

