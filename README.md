# data-structure-and-algorithms
《算法导论》
==
#第一部分 基础知识
##第一章
如何任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
“旅行商问题”是NP完全的，归并排序的算法时间正比于nlogn，而插入排序正比于n*n
##第二章
分治算法
一个简单的例子是两堆已经各自排好序的扑克牌,分别比较两堆顶部的牌,把较小的放进第三个最终数组,被抽走的那堆显露新的牌再进行比较
##第三章
函数的增长
3.1
若f(n)=Θ(g(n)),则称g(n)是f(n)的一个渐近紧确界,如果当n>n0时,f(n)小于等于cg(n),则记f(n)=O(g(n)),如果f(n)总大于等于cg(n),则记f(n)=Ω(g(n)).
用o记号表示一个非渐近紧确的上界，o(g(n))记为f(n)<cg(n),注意与大O符号的区别。
用ω记号表示一个非渐近紧确的下界，ω与Ω的关系与o与O记号的关系类似
3.2
向下取整表示小于或等于x的最大整数，向上取整表示大于或者等于x的最小整数
斯特林公式给出了n的阶乘的近似表达式
斐波那契数与黄金分割率fai以及其共轭数有关
##第四章
分治策略
4.2矩阵乘法的Strassen算法
可以通过这个算法把矩阵乘法由基本的Ω(n^3)变为O（n^lg7),但是63页指出,从实用的角度,Strassen算法通常不是解决矩阵乘法的最优选择.
4.3用代入算法求解递归式
分治策略就是把一个大问题分解成很多相似的小问题,在得出递归式后可以尝试猜测出递归式的时间复杂度的具体表现形式,,然后代入得出上界或是下界
4.4用递归树方法求解递归式的表达式,递归式所有结点的代价之和即为总的算法复杂度
4.5用主方法求解递归式有固定的方法
##第五章 
概率分析和随机算法
#第二部分 排序和顺序统计量
##第六章
堆排序
（二叉）堆可以被近似看成一个完全二叉树，除了最底层外，该树是完全充满的
时间复杂度O(nlgn),最大堆与最小堆的概念,构造一个最大堆,以及对堆进行排序,得到一个有序数组
由sedgewick的《算法》可以知道可以用一个数组来表示堆，最顶点放在第一个位置
##第七章
快速排序
在排序算法中，如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是
原址的
快速排序的期望时间复杂度是Θ（nlgn），最坏情况是Θ（n^2)
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
只要分割的两部分比例是常数，算法的运行时间总是O（nlgn）
可以用RANDOMIZED-QUICKSORT首先随机选择主元可以得到期望运行时间
##第八章 线性时间排序
在最坏情况下，任何比较排序算法都要做Ω（nlgn）次比较
###8.2计数排序
计数排序就是有多少个元素小于它就把它放在第几个位置，计数排序的重要性质就是稳定性，具有相同值的元素在输出中相对次序与输入中的相对次序相同
###8.3基数排序  基数排序是一种稳定性排序，是从低位到高位进行排序
###8.4桶排序
桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），其期望运行时间为Θ（n）
9.1同时得到最大值和最小值可以先把输入的一对数据进行比较，然后较小的数据与暂时的最小值比较，较大的数据与暂时的最大值比较
9.2randomized-select方法寻找一个序列中第i小的元素，类似于快速排序，先把数组分为小于以及大于主元的两部分，然后在这两部分中的一个寻找所要求的元素。
9.3作者提出了求中位数的中位数的算法
##第三部分 数据结构
###第十章  基本数据结构
10.1队列是环序的
10.2在链表中可以设置一个哨兵，在代码中可以降低常数因子，使代码简洁
对于没有指针的语言可以用数组来构成链表，每一个对象的关键字，prev以及next都存放在数组中的一个位置上
###第十二章  二叉搜索树
二叉搜索树的高度为k-1，也就是根结点是第0层
Jensen不等式  将一个凸函数f(x)应用到随机变量X上时，假定期望存在且有限，则由詹森不等式可得E[f(x)]≥f(E[X])
###第十三章 红黑树
13.1每个结点红色或者黑色的，根节点是黑色的，对于每个结点从该节点到所有后代叶节点(NIL)的简单路径均包含相同数目的黑色结点。
红黑树:平衡二叉树，广泛用在C++的STL中。map和set都是用红黑树实现的，
统计性能比AVL树更高，AVL树是一种高度平衡的二叉搜索树，对于每个结点x，x的左右子树的高度差至多为1
13.3插入
把一个结点插入红黑树或者从红黑树上删除时，可能会违背红黑树的性质，所以要对红黑树重新染色以及旋转操作来满足红黑树的性质
###第十四章 数据结构的扩张
顺序统计树是在红黑树上添加存储信息，比如结点以下结点的数目总和。本章举例了扩张红黑树产生区间树
##第四部分  高级设计和分析技术
###第15章 动态规划
动态规划是付出额外的内存空间来节省计算时间,是典型的时空权衡的例子,子问题图G=(V,E)可以确定动态规划算法的运行时间.
动态规划就是对一个大问题的子问题进行求解,然后保存该子问题的结果,然后把问题逐渐扩大,扩大后的问题会用到之前小问题求解后的结果,这样就不用再去求其中的小问题,直接拿来结果用就可以<br>
####15.2 矩阵链乘法问题
多个矩阵相乘,乘的顺序会影响计算复杂度
卡特兰数又称卡塔兰数，英文名Catalan number，是
	组合数学中一个常出现在各种计数问题中出现的
	数列。以
	比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名，其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …
矩阵代数的中的定义，nontrivial=nonzero,AX=0, 如果行列式|A|=0，那么A不可逆， 则X有非平凡解；否则，A可逆，那么只有解X=0，即是平凡解。
适合用动态规划方法求解问题的两个要素:最优子结构(意思就是一个问题的最优解包含其子问题的最优解）以及子问题重叠。无权最长简单路径问题是NP完全的。简单路径：顶点序列中顶点不重复出现的路径
一个问题适合用动态规划去做要求子问题有无关性和重叠性，无关性即子问题不共享资源，比如求最短路径问题子问题之间没有重复的点，重叠性即问题的递归算法会反复求解相同的子问题。<br>
####15.4最长公共子序列问题（LCS问题，longest-common-subsequence problem）
给定两个序列X，Y，如果Z既是X的子序列也是Y的子序列，则称它是X和Y的公共子序列<br>
####15.5最优二叉搜索树
搜索代价最小的二叉搜索树称为最优二叉搜索树,构造最优二叉搜索树也可以采用动态规划的方法,一棵最优二叉搜索树的子树也是最优的
对于旅行商问题,如果把问题简化为双调巡游(bitonic tours),则存在多项式时间算法
###第16章贪心算法
如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质，此性质是能否应用动态规划和贪心算法的关键要素，另外一个关键要素是贪心选择性质。贪心算法可以解决分数背包问题，但是不能解决0-1背包问题。
前缀码（prefix code），没有任何码字是其他码字的前缀，这样做的好处是编码文件的开始码字是无歧义的
用拟阵可以求解任务调度问题,每个任务都有一个截止时间,超过截止时间会有一个惩罚值,可以想到一个server,有多个user请求观看视频,每个用户的容忍时间都不是一样的,也就是截止时间,利用这个可以实现任务的调度
###第17章摊还分析
这个分析的目的就是求数据结构中执行所有操作的平均时间，来评价操作的代价
聚合分析中每个操作赋予相同的代价，就是把n个操作整体进行考虑，
核算法不同操作可能会有不同代价，就是用一部分去支付花费，另外一部分·作为信用用于弥补后面支付不足的情况。


