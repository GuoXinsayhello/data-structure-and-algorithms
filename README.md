# data-structure-and-algorithms
《算法导论》
==
#第一部分 基础知识
##第一章
如何任何一个NP完全问题存在有效算法，那么所有NP完全问题都存在有效算法
“旅行商问题”是NP完全的，归并排序的算法时间正比于nlogn，而插入排序正比于n*n
##第二章
分治算法
一个简单的例子是两堆已经各自排好序的扑克牌,分别比较两堆顶部的牌,把较小的放进第三个最终数组,被抽走的那堆显露新的牌再进行比较
##第三章
函数的增长
3.1
若f(n)=Θ(g(n)),则称g(n)是f(n)的一个渐近紧确界,如果当n>n0时,f(n)小于等于cg(n),则记f(n)=O(g(n)),如果f(n)总大于等于cg(n),则记f(n)=Ω(g(n)).
用o记号表示一个非渐近紧确的上界，o(g(n))记为f(n)<cg(n),注意与大O符号的区别。
用ω记号表示一个非渐近紧确的下界，ω与Ω的关系与o与O记号的关系类似
3.2
向下取整表示小于或等于x的最大整数，向上取整表示大于或者等于x的最小整数
斯特林公式给出了n的阶乘的近似表达式
斐波那契数与黄金分割率fai以及其共轭数有关
##第四章
分治策略
4.2矩阵乘法的Strassen算法
可以通过这个算法把矩阵乘法由基本的Ω(n^3)变为O（n^lg7),但是63页指出,从实用的角度,Strassen算法通常不是解决矩阵乘法的最优选择.
4.3用代入算法求解递归式
分治策略就是把一个大问题分解成很多相似的小问题,在得出递归式后可以尝试猜测出递归式的时间复杂度的具体表现形式,,然后代入得出上界或是下界
4.4用递归树方法求解递归式的表达式,递归式所有结点的代价之和即为总的算法复杂度
4.5用主方法求解递归式有固定的方法
##第五章 
概率分析和随机算法
#第二部分 排序和顺序统计量
##第六章
堆排序
（二叉）堆可以被近似看成一个完全二叉树，除了最底层外，该树是完全充满的
时间复杂度O(nlgn),最大堆与最小堆的概念,构造一个最大堆,以及对堆进行排序,得到一个有序数组
由sedgewick的《算法》可以知道可以用一个数组来表示堆，最顶点放在第一个位置,并且a[0]不放元素，从a[1]开始放元素，这样可以满足k的父结点为a[k/2]
##第七章
快速排序
在排序算法中，如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是
原址的
快速排序的期望时间复杂度是Θ（nlgn），最坏情况是Θ（n^2)
快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
只要分割的两部分比例是常数，算法的运行时间总是O（nlgn）
可以用RANDOMIZED-QUICKSORT首先随机选择主元可以得到期望运行时间
##第八章 线性时间排序
在最坏情况下，任何比较排序算法都要做Ω（nlgn）次比较
###8.2计数排序
计数排序就是有多少个元素小于它就把它放在第几个位置，计数排序的重要性质就是稳定性，具有相同值的元素在输出中相对次序与输入中的相对次序相同
###8.3基数排序  
基数排序是一种稳定性排序，是从低位到高位进行排序
###8.4桶排序
桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），其期望运行时间为Θ（n）
9.1同时得到最大值和最小值可以先把输入的一对数据进行比较，然后较小的数据与暂时的最小值比较，较大的数据与暂时的最大值比较
9.2randomized-select方法寻找一个序列中第i小的元素，类似于快速排序，先把数组分为小于以及大于主元的两部分，然后在这两部分中的一个寻找所要求的元素。
9.3作者提出了求中位数的中位数的算法
##第三部分 数据结构
###第十章  基本数据结构
10.1队列是环序的
10.2在链表中可以设置一个哨兵，在代码中可以降低常数因子，使代码简洁
对于没有指针的语言可以用数组来构成链表，每一个对象的关键字，prev以及next都存放在数组中的一个位置上
###第十二章  二叉搜索树
二叉搜索树的高度为k-1，也就是根结点是第0层
Jensen不等式  将一个凸函数f(x)应用到随机变量X上时，假定期望存在且有限，则由詹森不等式可得E[f(x)]≥f(E[X])
###第十三章 红黑树
13.1每个结点红色或者黑色的，根节点是黑色的，对于每个结点从该节点到所有后代叶节点(NIL)的简单路径均包含相同数目的黑色结点。
红黑树:平衡二叉树，广泛用在C++的STL中。map和set都是用红黑树实现的，
统计性能比AVL树更高，AVL树是一种高度平衡的二叉搜索树，对于每个结点x，x的左右子树的高度差至多为1
13.3插入
把一个结点插入红黑树或者从红黑树上删除时，可能会违背红黑树的性质，所以要对红黑树重新染色以及旋转操作来满足红黑树的性质
###第十四章 数据结构的扩张
顺序统计树是在红黑树上添加存储信息，比如结点以下结点的数目总和。本章举例了扩张红黑树产生区间树
##第四部分  高级设计和分析技术
###第15章 动态规划
动态规划是付出额外的内存空间来节省计算时间,是典型的时空权衡的例子,子问题图G=(V,E)可以确定动态规划算法的运行时间.
动态规划就是对一个大问题的子问题进行求解,然后保存该子问题的结果,然后把问题逐渐扩大,扩大后的问题会用到之前小问题求解后的结果,这样就不用再去求其中的小问题,直接拿来结果用就可以<br>
####15.2 矩阵链乘法问题
多个矩阵相乘,乘的顺序会影响计算复杂度
卡特兰数又称卡塔兰数，英文名Catalan number，是
	组合数学中一个常出现在各种计数问题中出现的
	数列。以
	比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名，其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …
矩阵代数的中的定义，nontrivial=nonzero,AX=0, 如果行列式|A|=0，那么A不可逆， 则X有非平凡解；否则，A可逆，那么只有解X=0，即是平凡解。
适合用动态规划方法求解问题的两个要素:最优子结构(意思就是一个问题的最优解包含其子问题的最优解）以及子问题重叠。无权最长简单路径问题是NP完全的。简单路径：顶点序列中顶点不重复出现的路径
一个问题适合用动态规划去做要求子问题有无关性和重叠性，无关性即子问题不共享资源，比如求最短路径问题子问题之间没有重复的点，重叠性即问题的递归算法会反复求解相同的子问题。<br>
####15.4最长公共子序列问题（LCS问题，longest-common-subsequence problem）
给定两个序列X，Y，如果Z既是X的子序列也是Y的子序列，则称它是X和Y的公共子序列<br>
####15.5最优二叉搜索树
搜索代价最小的二叉搜索树称为最优二叉搜索树,构造最优二叉搜索树也可以采用动态规划的方法,一棵最优二叉搜索树的子树也是最优的
对于旅行商问题,如果把问题简化为双调巡游(bitonic tours),则存在多项式时间算法
###第16章贪心算法
如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质，此性质是能否应用动态规划和贪心算法的关键要素，另外一个关键要素是贪心选择性质。贪心算法可以解决分数背包问题，但是不能解决0-1背包问题。
前缀码（prefix code），没有任何码字是其他码字的前缀，这样做的好处是编码文件的开始码字是无歧义的
用拟阵可以求解任务调度问题,每个任务都有一个截止时间,超过截止时间会有一个惩罚值,可以想到一个server,有多个user请求观看视频,每个用户的容忍时间都不是一样的,也就是截止时间,利用这个可以实现任务的调度
###第17章摊还分析
这个分析的目的就是求数据结构中执行所有操作的平均时间，来评价操作的代价
聚合分析中每个操作赋予相同的代价，就是把n个操作整体进行考虑，
核算法不同操作可能会有不同代价，就是用一部分去支付花费，另外一部分·作为信用用于弥补后面支付不足的情况。
##第五部分  高级数据结构
###第18章 B树
B树的节点可以有多个孩子，一个结点包含x.n个关键字，则该结点有x.n+1个孩子，B树的最小度数t限定了结点包含关键字个数的上界和下界，每个内部结点最多2t-1个关键字，最少t-1个关键字,一棵高度为h的B树,最小度数为t,共有n个关键字,则h<=log(t)(n+1)/2(注释:该式表示以t为底)。由于B树中一个结点有多个孩子，所以在搜索时比普通的二叉树少很多搜索结点.向B树中插入一个新的关键字,当遇到满结点时可能会用到分裂操作.
当从B树中删除一个关键字时为了满足B树的条件,结点的关键字要不少于t-1,所以在删除的时候会分为很多不同的情况讨论.我就纳闷了,为了满足B树的条件,删除的时候太过于繁琐了,是否有一种削足适履的感觉.是否为为了满足B树的定义而增加了算法的复杂度
###第19章 斐波那契堆
理论上斐波那契堆部分操作的摊还时间要比二叉堆要小很多,但是实际当中编程复杂性相比二叉堆不是很适用.斐波那契堆是一系列具有最小堆序的有根树的集合,每棵树均遵循最小堆性质
斐波那契堆extract-min操作在结束之后保证root list的根结点的度数都不一样(度数就是根结点的子孩子数目)
设x是斐波那契堆中的任意结点，设k=x.degree，则有size（x）>=F(k+2)>=fai^k,其中fai=（1+根号5）/2,F(k+2)为第k+2个斐波那契数，size（x)为以x为根的子树中包括x本身在内的结点个数
###第20章 van Emde Boas树
感觉第316页的图好像画错了，在min以及max中应该放置最小或者最大的元素，但是该图好像并不是这样。
vEB树支持在动态集合上运行时间为O（lglgn）的操作，就是把元素分成很多簇，并且在每一簇中都存储了min以及max，这样在查找某个元素的时候就会比较方便一点。
###第21章 用于不相交集合的数据结构
Find-set操作通过指向父结点的指针找到树的根
##第六部分 图算法
###第22章 基本的图算法
稀疏图(边的条数|E|远远小于|V|^2的图
BFS（广度优先搜索）的总运行时间是O（V+E），该算法的思想就是需要在发现所有距离源结点s为k的所有结点之后，才会发现距离源结点s为k+1的其他结点
DFS（深度优先搜索）,可以用来寻找结点的发现时间以及完成时间，会形成多个独立的子树，边分为后向边、前向边、树边以及横向边，总运行时间是西塔（V+E）
后代区间的嵌套：在有向图或者无向图G的深度优先森林中，结点v是结点u的真后代当且仅当u.d<v.d<v.f<u.f成立，d为发现时间（discover），f为完成时间（finish）
拓扑排序：利用DFS求出每个结点的finish time，结点次序与结点的完成时间恰好相反，可以在西塔（V+E）时间内完成拓扑排序
强联通分量是一个最大结点集合，对于该集合中的任意一对结点可以相互到达，G中连接不同强连通分量的每条边都是从完成时间较晚的分量指向完成时间较早的分量，而转置图反之。强连通分量算法就是对G进行一次DFS，然后再对G的转置进行一次DFS
![](https://github.com/GuoXinsayhello/data-structure-and-algorithms/tree/master/picture/graph.jpg)
###第23章 最小生成树
最小生成树问题就是把所有结点连接起来并且具有最小权重。
解决这两种问题有Kruskal算法以及Prim算法，这两种算法都是贪心算法
Kruskal算法就是在图G（V，E）中首先形成V棵树，然后按照边的权重寻找权重最小的边并考虑其是否加入集合，该算法的总运行时间O（ElgV）
Prim算法类似Dijkstra算法，就是从任意一个根结点开始，不断向其中加入轻量级的边，形成一个集合，选择集合外最小的边加入集合，直到覆盖所有结点，该算法的运行时间也是O（ElgV),如果采用斐波那契堆得话，则Prim算法的运行时间改进为O（E+VlgV）
###第24章 单源最短路径
Bellman-ford算法是求含负权图的单源最短路径算法，就是对每条边进行持续的松弛，效率很低，如果有负权重的环路存在，则输出一个bool值，
最短路径算法依赖最短路径的一个重要性质：两个节点之间的一条最短路径包含着其他的最短路径，Dijkstra算法是一个贪心算法，而Floyd-Warshall算法是一个动态规划算法，单源最短路径不会包含环路。
在求单源最短路径时，对一条边的（u，v）的松弛过程为:从节点s到节点u之间的最短路径距离加上节点u与v之间的边权重，并且与当前的s到v的最短路径估计进行比较，如果前者更小，则对v.d  v.pi进行更新。
Dijkstra算法就是重复从结点集V-S中选择最短路径估计最小的结点u，把u加入到集合S中，然后对所有从u发出的边进行松弛
其中Dijkstra算法和用于有向无环图的最短路径算法对每条边仅松弛一次。Bellman-Ford算法对每条边松弛|v|-1次，且该方法需要的运行总时间是O（VE）
Dijkstra算法的运行时间要低于Bellman-Ford算法的运行时间，该算法解决的是带权重的有向图上单源最短路径问题，要求所有边的权重非负，该算法使用的是贪心策略
单纯形算法并不总能在多项式时间内完成线性规划问题
差分约束系统：线性规划矩阵A的每一行包括一个1和一个-1，其他所有项都为0
可以用Bellman-ford算法来求解差分约束系统
###第25 章 所有结点对的最短路径问题
前驱结点矩阵：从结点I到结点j的最短路径结点j的前驱结点
####25.1 最短路径和矩阵乘法
这个算法的思想就是在寻找两个结点之间的最短路径，从之间的中间结点为0个，1个，一直到n-2个
而改进后的重复平方法可以把运行时间改进为西塔（n^3lgn),其思想和上述的差不多，只不过中间点数不是每次以1递增，而是以2的倍数递增
####25.2 Floyd-Warshall算法
Floyd-Warshall算法，其运行时间为西塔（V^3),具体思想如下：
![](https://github.com/GuoXinsayhello/data-structure-and-algorithms/tree/master/picture/graph2.jpg)
图G的传递闭包为图G*=（V，E*），其中E*={（i，j）：如果图G包含一条从结点i到j的路径}，传递闭包算法的运行时间也是西塔（n^3)
####25.3 用于稀疏图的Johnson算法
该算法可以在O（V^2lgV+VE)时间内找到所有结点对的最短路径，
核心技术就是重新赋予权重，如果所有权重非负，就对每个结点运行一次Dijkstra算法，如果有权重为负的环路，就报告，如果有权重为负，但是不是环路，就重新计算出一组非负权重值，然后再用Dijkstra算法
当路径中出现负值的路径时，可以把每条路径都加上一个数（该数为（-最小的权重值）+1），这样就出现了非负的路径了
###第26章 最大流
横跨任何切割的净流量都相同，都等于|f|,即流的值
最大流最小切割定理：
	1、f是G的一个最大流
	2、残存网络不包括任何增广路径
	3、|f|=c（S,T），其中（S,T）是流网络G的某个切割
求最大流的Ford-Fulkerson算法
就是不断利用残存网络寻找增广路径p，然后不断增加p上的流，这种算法在容量都是整数且最优的流量值较小时，表现比较好，然而当最优的流量值比较大的时候这种算法的运行效果并不是很好
####26.2 Edmonds-Karp算法
该算法是对Ford-Fulkerson算法的改进，是在寻找增广路径中用广度优先搜索来改善算法的效率，其运行时间为O（VE^2)
####26.3图G中一个匹配直接对应G所对应的流网络G‘中的一个流，其中一个最大匹配对应一个最大流
####26.4推送-重贴标签算法
该算法的运行时间为O（V^2E)，而前置重贴标签算法是对推送-重贴标签算法的一种改进，该算法维持一个结点的链表，其运行时间为O（V^3)
